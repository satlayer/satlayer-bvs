{"abi":[{"type":"function","name":"cancelSlashing","inputs":[{"name":"slashId","type":"bytes32","internalType":"bytes32"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"finalizeSlashing","inputs":[{"name":"slashId","type":"bytes32","internalType":"bytes32"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getLockedAssets","inputs":[{"name":"slashId","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"","type":"tuple[]","internalType":"struct ISLAYRouterSlashingV2.LockedAssets[]","components":[{"name":"amount","type":"uint256","internalType":"uint256"},{"name":"vault","type":"address","internalType":"address"}]}],"stateMutability":"view"},{"type":"function","name":"getPendingSlashingRequest","inputs":[{"name":"service","type":"address","internalType":"address"},{"name":"operator","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"tuple","internalType":"struct ISLAYRouterSlashingV2.Request","components":[{"name":"status","type":"uint8","internalType":"enum ISLAYRouterSlashingV2.Status"},{"name":"service","type":"address","internalType":"address"},{"name":"mbips","type":"uint24","internalType":"uint24"},{"name":"timestamp","type":"uint32","internalType":"uint32"},{"name":"requestTime","type":"uint32","internalType":"uint32"},{"name":"operator","type":"address","internalType":"address"},{"name":"requestResolution","type":"uint32","internalType":"uint32"},{"name":"requestExpiry","type":"uint32","internalType":"uint32"}]}],"stateMutability":"view"},{"type":"function","name":"getPendingSlashingRequestId","inputs":[{"name":"service","type":"address","internalType":"address"},{"name":"operator","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"bytes32","internalType":"bytes32"}],"stateMutability":"view"},{"type":"function","name":"getSlashingRequest","inputs":[{"name":"slashId","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"","type":"tuple","internalType":"struct ISLAYRouterSlashingV2.Request","components":[{"name":"status","type":"uint8","internalType":"enum ISLAYRouterSlashingV2.Status"},{"name":"service","type":"address","internalType":"address"},{"name":"mbips","type":"uint24","internalType":"uint24"},{"name":"timestamp","type":"uint32","internalType":"uint32"},{"name":"requestTime","type":"uint32","internalType":"uint32"},{"name":"operator","type":"address","internalType":"address"},{"name":"requestResolution","type":"uint32","internalType":"uint32"},{"name":"requestExpiry","type":"uint32","internalType":"uint32"}]}],"stateMutability":"view"},{"type":"function","name":"guardrailApprove","inputs":[{"name":"slashId","type":"bytes32","internalType":"bytes32"},{"name":"approve","type":"bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"lockSlashing","inputs":[{"name":"slashId","type":"bytes32","internalType":"bytes32"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"requestSlashing","inputs":[{"name":"payload","type":"tuple","internalType":"struct ISLAYRouterSlashingV2.Payload","components":[{"name":"operator","type":"address","internalType":"address"},{"name":"mbips","type":"uint24","internalType":"uint24"},{"name":"timestamp","type":"uint32","internalType":"uint32"},{"name":"reason","type":"string","internalType":"string"}]}],"outputs":[{"name":"slashId","type":"bytes32","internalType":"bytes32"}],"stateMutability":"nonpayable"},{"type":"event","name":"GuardrailApproval","inputs":[{"name":"slashId","type":"bytes32","indexed":true,"internalType":"bytes32"},{"name":"approval","type":"bool","indexed":false,"internalType":"bool"}],"anonymous":false},{"type":"event","name":"SlashingCanceled","inputs":[{"name":"service","type":"address","indexed":true,"internalType":"address"},{"name":"operator","type":"address","indexed":true,"internalType":"address"},{"name":"slashId","type":"bytes32","indexed":true,"internalType":"bytes32"}],"anonymous":false},{"type":"event","name":"SlashingFinalized","inputs":[{"name":"service","type":"address","indexed":true,"internalType":"address"},{"name":"operator","type":"address","indexed":true,"internalType":"address"},{"name":"slashId","type":"bytes32","indexed":true,"internalType":"bytes32"},{"name":"destination","type":"address","indexed":false,"internalType":"address"}],"anonymous":false},{"type":"event","name":"SlashingLocked","inputs":[{"name":"service","type":"address","indexed":true,"internalType":"address"},{"name":"operator","type":"address","indexed":true,"internalType":"address"},{"name":"slashId","type":"bytes32","indexed":true,"internalType":"bytes32"}],"anonymous":false},{"type":"event","name":"SlashingRequested","inputs":[{"name":"service","type":"address","indexed":true,"internalType":"address"},{"name":"operator","type":"address","indexed":true,"internalType":"address"},{"name":"slashId","type":"bytes32","indexed":true,"internalType":"bytes32"},{"name":"request","type":"tuple","indexed":false,"internalType":"struct ISLAYRouterSlashingV2.Request","components":[{"name":"status","type":"uint8","internalType":"enum ISLAYRouterSlashingV2.Status"},{"name":"service","type":"address","internalType":"address"},{"name":"mbips","type":"uint24","internalType":"uint24"},{"name":"timestamp","type":"uint32","internalType":"uint32"},{"name":"requestTime","type":"uint32","internalType":"uint32"},{"name":"operator","type":"address","internalType":"address"},{"name":"requestResolution","type":"uint32","internalType":"uint32"},{"name":"requestExpiry","type":"uint32","internalType":"uint32"}]},{"name":"reason","type":"string","indexed":false,"internalType":"string"}],"anonymous":false},{"type":"error","name":"GuardrailHasDetermined","inputs":[]},{"type":"error","name":"GuardrailHaveNotApproved","inputs":[]},{"type":"error","name":"InvalidStatus","inputs":[]},{"type":"error","name":"SlashingRequestExpired","inputs":[]},{"type":"error","name":"SlashingRequestNotFound","inputs":[]},{"type":"error","name":"SlashingResolutionNotReached","inputs":[]},{"type":"error","name":"Unauthorized","inputs":[]}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"cancelSlashing(bytes32)":"deec65bc","finalizeSlashing(bytes32)":"4eb30bc9","getLockedAssets(bytes32)":"dd717644","getPendingSlashingRequest(address,address)":"0b78623b","getPendingSlashingRequestId(address,address)":"002cf9a4","getSlashingRequest(bytes32)":"53dd91f5","guardrailApprove(bytes32,bool)":"b4867fe4","lockSlashing(bytes32)":"17afb65b","requestSlashing((address,uint24,uint32,string))":"1838efe5"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"GuardrailHasDetermined\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GuardrailHaveNotApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlashingRequestExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlashingRequestNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlashingResolutionNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approval\",\"type\":\"bool\"}],\"name\":\"GuardrailApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"}],\"name\":\"SlashingCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"SlashingFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"}],\"name\":\"SlashingLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"enum ISLAYRouterSlashingV2.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"mbips\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"requestTime\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"requestResolution\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"requestExpiry\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct ISLAYRouterSlashingV2.Request\",\"name\":\"request\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"SlashingRequested\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"}],\"name\":\"cancelSlashing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"}],\"name\":\"finalizeSlashing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"}],\"name\":\"getLockedAssets\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"internalType\":\"struct ISLAYRouterSlashingV2.LockedAssets[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"getPendingSlashingRequest\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ISLAYRouterSlashingV2.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"mbips\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"requestTime\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"requestResolution\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"requestExpiry\",\"type\":\"uint32\"}],\"internalType\":\"struct ISLAYRouterSlashingV2.Request\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"getPendingSlashingRequestId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"}],\"name\":\"getSlashingRequest\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ISLAYRouterSlashingV2.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"mbips\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"requestTime\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"requestResolution\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"requestExpiry\",\"type\":\"uint32\"}],\"internalType\":\"struct ISLAYRouterSlashingV2.Request\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"approve\",\"type\":\"bool\"}],\"name\":\"guardrailApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"}],\"name\":\"lockSlashing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"mbips\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"internalType\":\"struct ISLAYRouterSlashingV2.Payload\",\"name\":\"payload\",\"type\":\"tuple\"}],\"name\":\"requestSlashing\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"slashId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface for the slashing functionality in the SatLayer protocol. This interface defines the structure and functions for slashing requests, which are penalties applied to operators for violations or non-compliance. It is designed to be implemented on the SLAYRouter, but separated to allow for clear separation of slashing-related concerns from other router functionality.\",\"errors\":{\"GuardrailHasDetermined()\":[{\"details\":\"Error thrown when guardrail attempts to approve/reject a slashing request more than once.\"}],\"GuardrailHaveNotApproved()\":[{\"details\":\"Error thrown when attempting to finalize a slashing request that has not been approved by the guardrail.\"}],\"InvalidStatus()\":[{\"details\":\"Error thrown when an operation is attempted on a slashing request with an invalid status.\"}],\"SlashingRequestExpired()\":[{\"details\":\"Error thrown when an operation is attempted on a slashing request that has expired.\"}],\"SlashingRequestNotFound()\":[{\"details\":\"Error thrown when an operation references a slashing request that does not exist.\"}],\"SlashingResolutionNotReached()\":[{\"details\":\"Error thrown when attempting to lock a slashing request before its resolution window has passed.\"}],\"Unauthorized()\":[{\"details\":\"Error thrown when an unauthorized address attempts to perform a restricted operation.\"}]},\"events\":{\"GuardrailApproval(bytes32,bool)\":{\"details\":\"Emitted when a slashing request has been approved or rejected by the guardrail. The guardrail is a security mechanism that provides additional approval for slashing operations.\",\"params\":{\"approval\":\"True if the guardrail approved the slashing request, false if rejected.\",\"slashId\":\"The unique identifier for the slashing request that received a decision.\"}},\"SlashingCanceled(address,address,bytes32)\":{\"details\":\"Emitted when a slashing request has been canceled. This occurs when a service explicitly cancels a pending request or when a new request replaces an expired one.\",\"params\":{\"operator\":\"The address of the operator that was targeted by the canceled request.\",\"service\":\"The address of the service that requested the slashing.\",\"slashId\":\"The unique identifier for the canceled slashing request.\"}},\"SlashingFinalized(address,address,bytes32,address)\":{\"details\":\"Emitted when a slashing request has been finalized. This event is emitted when the slashed collateral is moved from the router to the destination address. The destination address is agreed upon by the service and the operator in the slashing parameters. Finalization can only occur after locking and guardrail approval.\",\"params\":{\"destination\":\"The address to which the slashed collateral was sent.\",\"operator\":\"The address of the operator whose collateral was slashed.\",\"service\":\"The address of the service that requested the slashing.\",\"slashId\":\"The unique identifier for the finalized slashing request.\"}},\"SlashingLocked(address,address,bytes32)\":{\"details\":\"Emitted when a slashing request has been locked. This event is emitted when the slashed collateral is moved from the operator's vaults to the router for further processing. Locking occurs after the resolution window has passed and before the request expires.\",\"params\":{\"operator\":\"The address of the operator whose collateral is being locked.\",\"service\":\"The address of the service that requested the slashing.\",\"slashId\":\"The unique identifier for the locked slashing request.\"}},\"SlashingRequested(address,address,bytes32,(uint8,address,uint24,uint32,uint32,address,uint32,uint32),string)\":{\"details\":\"Emitted when a new slashing request is created.\",\"params\":{\"operator\":\"The address of the operator being slashed.\",\"reason\":\"The reason for the slashing request, a human-readable string. Not stored on-chain.\",\"request\":\"The information about the slashing request.\",\"service\":\"The address of the service that requested the slashing.\",\"slashId\":\"The unique identifier for the slashing request.\"}}},\"kind\":\"dev\",\"methods\":{\"cancelSlashing(bytes32)\":{\"details\":\"Allows a service to cancel its own pending slashing request. This function: - Can only be called by the service that initiated the slashing request. - Can only be called if the request is in the Pending status. - Changes the request status from Pending to Canceled. - Removes the request from the pending requests mapping. Once canceled, a slashing request cannot be reactivated, but a new request can be created.\",\"params\":{\"slashId\":\"The unique identifier for the slashing request to cancel.\"}},\"finalizeSlashing(bytes32)\":{\"details\":\"Completes the slashing process by moving the locked assets from the router to the destination address specified in the slashing parameters. This function: - Can only be called by the service that initiated the slashing request. - Can only be executed if the request is in the Locked status. - Requires prior approval from the guardrail. - Changes the request status from Locked to Finalized. After finalization, the slashing process is complete and cannot be reversed.\",\"params\":{\"slashId\":\"The unique identifier for the slashing request to finalize.\"}},\"getLockedAssets(bytes32)\":{\"details\":\"Returns an array of LockedAssets structs representing the assets that have been locked as part of the slashing process. This information is only relevant for requests in the Locked status.\",\"params\":{\"slashId\":\"The unique identifier for the slashing request.\"},\"returns\":{\"_0\":\"An array of LockedAssets structs containing information about the locked assets.\"}},\"getPendingSlashingRequest(address,address)\":{\"details\":\"Returns the most recent slashing request initiated by the specified service against the specified operator. If no pending request exists, the returned request will have default values.\",\"params\":{\"operator\":\"Address of the operator targeted by the slashing request.\",\"service\":\"Address of the service that initiated the slashing request.\"},\"returns\":{\"_0\":\"A Request struct containing the details of the current pending slashing request.\"}},\"getPendingSlashingRequestId(address,address)\":{\"details\":\"Returns the most recent slashing request id initiated by the specified service against the specified operator. If no pending request exists, the returned request id will be empty.\",\"params\":{\"operator\":\"Address of the operator targeted by the slashing request.\",\"service\":\"Address of the service that initiated the slashing request.\"},\"returns\":{\"_0\":\"bytes32 The unique identifier for the current pending slashing request.\"}},\"getSlashingRequest(bytes32)\":{\"details\":\"Returns the complete details of a slashing request identified by the provided slashId. If no request exists with the given slashId, the returned request will have default values.\",\"params\":{\"slashId\":\"The unique identifier for the slashing request to retrieve.\"},\"returns\":{\"_0\":\"A Request struct containing the details of the specified slashing request.\"}},\"guardrailApprove(bytes32,bool)\":{\"details\":\"Allows the designated guardrail address to approve or reject a slashing request before it can be finalized. This function: - Can only be called by the designated guardrail address. - Can only be called once per slashing request. - Does not check the status of the request (this will be checked during finalization). - Records the approval decision for later verification during finalization. The guardrail serves as an additional security mechanism to prevent unauthorized slashing. note: on rejection, the locked funds will not be returned to the vault due to the nature of rebasing that will cause losses to the stakers. During slashing, assets will be locked in the router which will impact the exchange rate of the vaults. If funds are reverted to the vaults, it is akin to donation to the vault which will distribute the reverted assets to all stakers including new stakers who did not get slashed. This is not the intended behaviour, hence the locked funds will not be returned to the vaults on rejection in phase 2.\",\"params\":{\"approve\":\"True to approve the slashing request, false to reject it.\",\"slashId\":\"The unique identifier for the slashing request to approve or reject.\"}},\"lockSlashing(bytes32)\":{\"details\":\"Initiates the movement of slashed collateral from the operator's vaults to the router for temporary holding before finalization. This function: - Moves the calculated portion of the operator's assets from all their vaults to the router. - Can only be called after the resolution window has passed and before the request expires. - Can only be called by the service that initiated the slashing request. - Changes the request status from Pending to Locked. The amount locked from each vault is calculated based on the mbips value in the request.\",\"params\":{\"slashId\":\"The unique identifier for the slashing request to lock.\"}},\"requestSlashing((address,uint24,uint32,string))\":{\"details\":\"Allows a registered service to request a slash of an operator's staked tokens as a penalty for violations or non-compliance. The slashing request must meet several criteria: - Only callable by registered services. - The service must be actively registered with the operator at the specified timestamp. - The slashing amount (in mbips) must not exceed the maxMbips set by the service. - The operator must have opted in to slashing at the specified timestamp. - The timestamp must be within the allowable slashing window (not too old or in the future). - The service must not have another active slashing request against the same operator. - The reason provided must not exceed the maximum allowed length (250 characters). When successful, this creates a slashing request with an expiry time based on the resolutionWindow parameter and returns a unique slashing request ID.\",\"params\":{\"payload\":\"The slashing request payload containing the operator, mbips, timestamp, and reason.\"},\"returns\":{\"slashId\":\"The unique identifier for the newly created slashing request.\"}}},\"title\":\"SLAY Router Slashing V2 Interface\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"node_modules/@satlayer/contracts/src/interface/ISLAYRouterSlashingV2.sol\":\"ISLAYRouterSlashingV2\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[\":@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\":@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\":@openzeppelin/foundry-upgrades/=node_modules/@openzeppelin/foundry-upgrades/src/\",\":@satlayer/contracts/=node_modules/@satlayer/contracts/src/\",\":forge-std/=node_modules/forge-std/src/\",\":solidity-bytes-utils/=node_modules/solidity-bytes-utils/\"]},\"sources\":{\"node_modules/@satlayer/contracts/src/interface/ISLAYRouterSlashingV2.sol\":{\"keccak256\":\"0x2646cba81e9d4a9d7355bf82d0ae15975372446cf063630de83c443b6fbec182\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://5930245bf72345a5225ce6ee11b0dcea27c6a7adc97030a5f16f2bb4182cdbbf\",\"dweb:/ipfs/QmbV3Y2sQHyPF1WgbWZQKHvh63gDnFWp3ixPhaqDPhBDCU\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.24+commit.e11b9ed9"},"language":"Solidity","output":{"abi":[{"inputs":[],"type":"error","name":"GuardrailHasDetermined"},{"inputs":[],"type":"error","name":"GuardrailHaveNotApproved"},{"inputs":[],"type":"error","name":"InvalidStatus"},{"inputs":[],"type":"error","name":"SlashingRequestExpired"},{"inputs":[],"type":"error","name":"SlashingRequestNotFound"},{"inputs":[],"type":"error","name":"SlashingResolutionNotReached"},{"inputs":[],"type":"error","name":"Unauthorized"},{"inputs":[{"internalType":"bytes32","name":"slashId","type":"bytes32","indexed":true},{"internalType":"bool","name":"approval","type":"bool","indexed":false}],"type":"event","name":"GuardrailApproval","anonymous":false},{"inputs":[{"internalType":"address","name":"service","type":"address","indexed":true},{"internalType":"address","name":"operator","type":"address","indexed":true},{"internalType":"bytes32","name":"slashId","type":"bytes32","indexed":true}],"type":"event","name":"SlashingCanceled","anonymous":false},{"inputs":[{"internalType":"address","name":"service","type":"address","indexed":true},{"internalType":"address","name":"operator","type":"address","indexed":true},{"internalType":"bytes32","name":"slashId","type":"bytes32","indexed":true},{"internalType":"address","name":"destination","type":"address","indexed":false}],"type":"event","name":"SlashingFinalized","anonymous":false},{"inputs":[{"internalType":"address","name":"service","type":"address","indexed":true},{"internalType":"address","name":"operator","type":"address","indexed":true},{"internalType":"bytes32","name":"slashId","type":"bytes32","indexed":true}],"type":"event","name":"SlashingLocked","anonymous":false},{"inputs":[{"internalType":"address","name":"service","type":"address","indexed":true},{"internalType":"address","name":"operator","type":"address","indexed":true},{"internalType":"bytes32","name":"slashId","type":"bytes32","indexed":true},{"internalType":"struct ISLAYRouterSlashingV2.Request","name":"request","type":"tuple","components":[{"internalType":"enum ISLAYRouterSlashingV2.Status","name":"status","type":"uint8"},{"internalType":"address","name":"service","type":"address"},{"internalType":"uint24","name":"mbips","type":"uint24"},{"internalType":"uint32","name":"timestamp","type":"uint32"},{"internalType":"uint32","name":"requestTime","type":"uint32"},{"internalType":"address","name":"operator","type":"address"},{"internalType":"uint32","name":"requestResolution","type":"uint32"},{"internalType":"uint32","name":"requestExpiry","type":"uint32"}],"indexed":false},{"internalType":"string","name":"reason","type":"string","indexed":false}],"type":"event","name":"SlashingRequested","anonymous":false},{"inputs":[{"internalType":"bytes32","name":"slashId","type":"bytes32"}],"stateMutability":"nonpayable","type":"function","name":"cancelSlashing"},{"inputs":[{"internalType":"bytes32","name":"slashId","type":"bytes32"}],"stateMutability":"nonpayable","type":"function","name":"finalizeSlashing"},{"inputs":[{"internalType":"bytes32","name":"slashId","type":"bytes32"}],"stateMutability":"view","type":"function","name":"getLockedAssets","outputs":[{"internalType":"struct ISLAYRouterSlashingV2.LockedAssets[]","name":"","type":"tuple[]","components":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"vault","type":"address"}]}]},{"inputs":[{"internalType":"address","name":"service","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"stateMutability":"view","type":"function","name":"getPendingSlashingRequest","outputs":[{"internalType":"struct ISLAYRouterSlashingV2.Request","name":"","type":"tuple","components":[{"internalType":"enum ISLAYRouterSlashingV2.Status","name":"status","type":"uint8"},{"internalType":"address","name":"service","type":"address"},{"internalType":"uint24","name":"mbips","type":"uint24"},{"internalType":"uint32","name":"timestamp","type":"uint32"},{"internalType":"uint32","name":"requestTime","type":"uint32"},{"internalType":"address","name":"operator","type":"address"},{"internalType":"uint32","name":"requestResolution","type":"uint32"},{"internalType":"uint32","name":"requestExpiry","type":"uint32"}]}]},{"inputs":[{"internalType":"address","name":"service","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"stateMutability":"view","type":"function","name":"getPendingSlashingRequestId","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}]},{"inputs":[{"internalType":"bytes32","name":"slashId","type":"bytes32"}],"stateMutability":"view","type":"function","name":"getSlashingRequest","outputs":[{"internalType":"struct ISLAYRouterSlashingV2.Request","name":"","type":"tuple","components":[{"internalType":"enum ISLAYRouterSlashingV2.Status","name":"status","type":"uint8"},{"internalType":"address","name":"service","type":"address"},{"internalType":"uint24","name":"mbips","type":"uint24"},{"internalType":"uint32","name":"timestamp","type":"uint32"},{"internalType":"uint32","name":"requestTime","type":"uint32"},{"internalType":"address","name":"operator","type":"address"},{"internalType":"uint32","name":"requestResolution","type":"uint32"},{"internalType":"uint32","name":"requestExpiry","type":"uint32"}]}]},{"inputs":[{"internalType":"bytes32","name":"slashId","type":"bytes32"},{"internalType":"bool","name":"approve","type":"bool"}],"stateMutability":"nonpayable","type":"function","name":"guardrailApprove"},{"inputs":[{"internalType":"bytes32","name":"slashId","type":"bytes32"}],"stateMutability":"nonpayable","type":"function","name":"lockSlashing"},{"inputs":[{"internalType":"struct ISLAYRouterSlashingV2.Payload","name":"payload","type":"tuple","components":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"uint24","name":"mbips","type":"uint24"},{"internalType":"uint32","name":"timestamp","type":"uint32"},{"internalType":"string","name":"reason","type":"string"}]}],"stateMutability":"nonpayable","type":"function","name":"requestSlashing","outputs":[{"internalType":"bytes32","name":"slashId","type":"bytes32"}]}],"devdoc":{"kind":"dev","methods":{"cancelSlashing(bytes32)":{"details":"Allows a service to cancel its own pending slashing request. This function: - Can only be called by the service that initiated the slashing request. - Can only be called if the request is in the Pending status. - Changes the request status from Pending to Canceled. - Removes the request from the pending requests mapping. Once canceled, a slashing request cannot be reactivated, but a new request can be created.","params":{"slashId":"The unique identifier for the slashing request to cancel."}},"finalizeSlashing(bytes32)":{"details":"Completes the slashing process by moving the locked assets from the router to the destination address specified in the slashing parameters. This function: - Can only be called by the service that initiated the slashing request. - Can only be executed if the request is in the Locked status. - Requires prior approval from the guardrail. - Changes the request status from Locked to Finalized. After finalization, the slashing process is complete and cannot be reversed.","params":{"slashId":"The unique identifier for the slashing request to finalize."}},"getLockedAssets(bytes32)":{"details":"Returns an array of LockedAssets structs representing the assets that have been locked as part of the slashing process. This information is only relevant for requests in the Locked status.","params":{"slashId":"The unique identifier for the slashing request."},"returns":{"_0":"An array of LockedAssets structs containing information about the locked assets."}},"getPendingSlashingRequest(address,address)":{"details":"Returns the most recent slashing request initiated by the specified service against the specified operator. If no pending request exists, the returned request will have default values.","params":{"operator":"Address of the operator targeted by the slashing request.","service":"Address of the service that initiated the slashing request."},"returns":{"_0":"A Request struct containing the details of the current pending slashing request."}},"getPendingSlashingRequestId(address,address)":{"details":"Returns the most recent slashing request id initiated by the specified service against the specified operator. If no pending request exists, the returned request id will be empty.","params":{"operator":"Address of the operator targeted by the slashing request.","service":"Address of the service that initiated the slashing request."},"returns":{"_0":"bytes32 The unique identifier for the current pending slashing request."}},"getSlashingRequest(bytes32)":{"details":"Returns the complete details of a slashing request identified by the provided slashId. If no request exists with the given slashId, the returned request will have default values.","params":{"slashId":"The unique identifier for the slashing request to retrieve."},"returns":{"_0":"A Request struct containing the details of the specified slashing request."}},"guardrailApprove(bytes32,bool)":{"details":"Allows the designated guardrail address to approve or reject a slashing request before it can be finalized. This function: - Can only be called by the designated guardrail address. - Can only be called once per slashing request. - Does not check the status of the request (this will be checked during finalization). - Records the approval decision for later verification during finalization. The guardrail serves as an additional security mechanism to prevent unauthorized slashing. note: on rejection, the locked funds will not be returned to the vault due to the nature of rebasing that will cause losses to the stakers. During slashing, assets will be locked in the router which will impact the exchange rate of the vaults. If funds are reverted to the vaults, it is akin to donation to the vault which will distribute the reverted assets to all stakers including new stakers who did not get slashed. This is not the intended behaviour, hence the locked funds will not be returned to the vaults on rejection in phase 2.","params":{"approve":"True to approve the slashing request, false to reject it.","slashId":"The unique identifier for the slashing request to approve or reject."}},"lockSlashing(bytes32)":{"details":"Initiates the movement of slashed collateral from the operator's vaults to the router for temporary holding before finalization. This function: - Moves the calculated portion of the operator's assets from all their vaults to the router. - Can only be called after the resolution window has passed and before the request expires. - Can only be called by the service that initiated the slashing request. - Changes the request status from Pending to Locked. The amount locked from each vault is calculated based on the mbips value in the request.","params":{"slashId":"The unique identifier for the slashing request to lock."}},"requestSlashing((address,uint24,uint32,string))":{"details":"Allows a registered service to request a slash of an operator's staked tokens as a penalty for violations or non-compliance. The slashing request must meet several criteria: - Only callable by registered services. - The service must be actively registered with the operator at the specified timestamp. - The slashing amount (in mbips) must not exceed the maxMbips set by the service. - The operator must have opted in to slashing at the specified timestamp. - The timestamp must be within the allowable slashing window (not too old or in the future). - The service must not have another active slashing request against the same operator. - The reason provided must not exceed the maximum allowed length (250 characters). When successful, this creates a slashing request with an expiry time based on the resolutionWindow parameter and returns a unique slashing request ID.","params":{"payload":"The slashing request payload containing the operator, mbips, timestamp, and reason."},"returns":{"slashId":"The unique identifier for the newly created slashing request."}}},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/","@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/","@openzeppelin/foundry-upgrades/=node_modules/@openzeppelin/foundry-upgrades/src/","@satlayer/contracts/=node_modules/@satlayer/contracts/src/","forge-std/=node_modules/forge-std/src/","solidity-bytes-utils/=node_modules/solidity-bytes-utils/"],"optimizer":{"enabled":false,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"node_modules/@satlayer/contracts/src/interface/ISLAYRouterSlashingV2.sol":"ISLAYRouterSlashingV2"},"evmVersion":"cancun","libraries":{}},"sources":{"node_modules/@satlayer/contracts/src/interface/ISLAYRouterSlashingV2.sol":{"keccak256":"0x2646cba81e9d4a9d7355bf82d0ae15975372446cf063630de83c443b6fbec182","urls":["bzz-raw://5930245bf72345a5225ce6ee11b0dcea27c6a7adc97030a5f16f2bb4182cdbbf","dweb:/ipfs/QmbV3Y2sQHyPF1WgbWZQKHvh63gDnFWp3ixPhaqDPhBDCU"],"license":"BUSL-1.1"}},"version":1},"id":77}