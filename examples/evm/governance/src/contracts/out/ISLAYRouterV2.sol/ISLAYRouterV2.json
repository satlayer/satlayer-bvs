{"abi":[{"type":"function","name":"getMaxVaultsPerOperator","inputs":[],"outputs":[{"name":"","type":"uint8","internalType":"uint8"}],"stateMutability":"view"},{"type":"function","name":"isVaultWhitelisted","inputs":[{"name":"vault_","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"setGuardrail","inputs":[{"name":"guardrail","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setMaxVaultsPerOperator","inputs":[{"name":"count","type":"uint8","internalType":"uint8"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setVaultWhitelist","inputs":[{"name":"vault_","type":"address","internalType":"address"},{"name":"isWhitelisted","type":"bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"event","name":"GuardrailUpdated","inputs":[{"name":"oldGuardrail","type":"address","indexed":true,"internalType":"address"},{"name":"guardrail","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"event","name":"MaxVaultsPerOperatorUpdated","inputs":[{"name":"oldCount","type":"uint8","indexed":false,"internalType":"uint8"},{"name":"count","type":"uint8","indexed":false,"internalType":"uint8"}],"anonymous":false},{"type":"event","name":"VaultWhitelisted","inputs":[{"name":"operator","type":"address","indexed":true,"internalType":"address"},{"name":"vault","type":"address","indexed":false,"internalType":"address"},{"name":"whitelisted","type":"bool","indexed":false,"internalType":"bool"}],"anonymous":false}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"getMaxVaultsPerOperator()":"97da0056","isVaultWhitelisted(address)":"b2037480","setGuardrail(address)":"33410dc4","setMaxVaultsPerOperator(uint8)":"8651060d","setVaultWhitelist(address,bool)":"3302a6a1"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldGuardrail\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardrail\",\"type\":\"address\"}],\"name\":\"GuardrailUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldCount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"count\",\"type\":\"uint8\"}],\"name\":\"MaxVaultsPerOperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"VaultWhitelisted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getMaxVaultsPerOperator\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"isVaultWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardrail\",\"type\":\"address\"}],\"name\":\"setGuardrail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"count\",\"type\":\"uint8\"}],\"name\":\"setMaxVaultsPerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"setVaultWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface for the SLAYRouterV2 contract, which serves as the central point for managing interactions with SLAYVaults.\",\"events\":{\"GuardrailUpdated(address,address)\":{\"details\":\"Emitted when the guardrail address is updated.\",\"params\":{\"guardrail\":\"The address of the new guardrail contract.\",\"oldGuardrail\":\"The address of the previous guardrail contract.\"}},\"MaxVaultsPerOperatorUpdated(uint8,uint8)\":{\"details\":\"Emitted when the maximum number of vaults per operator is updated.\",\"params\":{\"count\":\"The new maximum number of vaults allowed per operator.\",\"oldCount\":\"The previous maximum number of vaults allowed per operator.\"}},\"VaultWhitelisted(address,address,bool)\":{\"details\":\"Emitted when the vault whitelist status is updated.\",\"params\":{\"operator\":\"The address of the operator associated with the vault.\",\"vault\":\"The address of the vault whose whitelist status was updated.\",\"whitelisted\":\"The new whitelist status of the vault.\"}}},\"kind\":\"dev\",\"methods\":{\"getMaxVaultsPerOperator()\":{\"details\":\"This limit prevents a single operator from controlling too many vaults.\",\"returns\":{\"_0\":\"The maximum number of vaults allowed per operator.\"}},\"isVaultWhitelisted(address)\":{\"details\":\"Check if a vault is whitelisted.\",\"params\":{\"vault_\":\"The address of the vault to check.\"},\"returns\":{\"_0\":\"A boolean indicating whether the vault is whitelisted (true) or not (false).\"}},\"setGuardrail(address)\":{\"details\":\"Set the guardrail address. Only callable by the owner.\",\"params\":{\"guardrail\":\"The address of the new guardrail contract.\"}},\"setMaxVaultsPerOperator(uint8)\":{\"details\":\"The new value must be greater than the previous value to prevent existing operators from exceeding the limit. Only callable by the owner.\",\"params\":{\"count\":\"The new maximum number of vaults per operator.\"}},\"setVaultWhitelist(address,bool)\":{\"details\":\"This allows the contract owner to control which vaults can be interacted with through the router. For non-granular state control, use the pause functionality to pause all vaults. When a vault is whitelisted, it can be interacted with through the router. The function will revert if the vault is already in the desired state.\",\"params\":{\"isWhitelisted\":\"The whitelist status to set (true to whitelist, false to un-whitelist).\",\"vault_\":\"The address of the vault to set the whitelist status for. This should be a SLAYVault contract address but isn't \\\"strictly checked\\\" (it is not possible to enforce this) to allow for flexible un-whitelisting of vaults for emergency purposes. Importantly: VaultFactory is not used to create vaults using the beacon pattern. Vaults are NOT automatically whitelisted when created to allow for vaults flexibility. This might change in the future.\"}}},\"title\":\"Vaults Router Interface\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"node_modules/@satlayer/contracts/src/interface/ISLAYRouterV2.sol\":\"ISLAYRouterV2\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[\":@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\":@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\":@openzeppelin/foundry-upgrades/=node_modules/@openzeppelin/foundry-upgrades/src/\",\":@satlayer/contracts/=node_modules/@satlayer/contracts/src/\",\":forge-std/=node_modules/forge-std/src/\",\":solidity-bytes-utils/=node_modules/solidity-bytes-utils/\"]},\"sources\":{\"node_modules/@satlayer/contracts/src/interface/ISLAYRouterV2.sol\":{\"keccak256\":\"0x5977420f6dbe0cbe211094e6b11bc70d069ff152f6504efe4a8bd342ac30e93b\",\"license\":\"BUSL-1.1\",\"urls\":[\"bzz-raw://b0c6c50282e932a0a9ca6d5f9b44d6dd6b9430f9bbb0ce9bab420333bced0f12\",\"dweb:/ipfs/Qmazc4YJJoV9TpvonP7RnZ3EC34c7YXRMECEjg3GHurA4N\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.24+commit.e11b9ed9"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"oldGuardrail","type":"address","indexed":true},{"internalType":"address","name":"guardrail","type":"address","indexed":true}],"type":"event","name":"GuardrailUpdated","anonymous":false},{"inputs":[{"internalType":"uint8","name":"oldCount","type":"uint8","indexed":false},{"internalType":"uint8","name":"count","type":"uint8","indexed":false}],"type":"event","name":"MaxVaultsPerOperatorUpdated","anonymous":false},{"inputs":[{"internalType":"address","name":"operator","type":"address","indexed":true},{"internalType":"address","name":"vault","type":"address","indexed":false},{"internalType":"bool","name":"whitelisted","type":"bool","indexed":false}],"type":"event","name":"VaultWhitelisted","anonymous":false},{"inputs":[],"stateMutability":"view","type":"function","name":"getMaxVaultsPerOperator","outputs":[{"internalType":"uint8","name":"","type":"uint8"}]},{"inputs":[{"internalType":"address","name":"vault_","type":"address"}],"stateMutability":"view","type":"function","name":"isVaultWhitelisted","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"guardrail","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setGuardrail"},{"inputs":[{"internalType":"uint8","name":"count","type":"uint8"}],"stateMutability":"nonpayable","type":"function","name":"setMaxVaultsPerOperator"},{"inputs":[{"internalType":"address","name":"vault_","type":"address"},{"internalType":"bool","name":"isWhitelisted","type":"bool"}],"stateMutability":"nonpayable","type":"function","name":"setVaultWhitelist"}],"devdoc":{"kind":"dev","methods":{"getMaxVaultsPerOperator()":{"details":"This limit prevents a single operator from controlling too many vaults.","returns":{"_0":"The maximum number of vaults allowed per operator."}},"isVaultWhitelisted(address)":{"details":"Check if a vault is whitelisted.","params":{"vault_":"The address of the vault to check."},"returns":{"_0":"A boolean indicating whether the vault is whitelisted (true) or not (false)."}},"setGuardrail(address)":{"details":"Set the guardrail address. Only callable by the owner.","params":{"guardrail":"The address of the new guardrail contract."}},"setMaxVaultsPerOperator(uint8)":{"details":"The new value must be greater than the previous value to prevent existing operators from exceeding the limit. Only callable by the owner.","params":{"count":"The new maximum number of vaults per operator."}},"setVaultWhitelist(address,bool)":{"details":"This allows the contract owner to control which vaults can be interacted with through the router. For non-granular state control, use the pause functionality to pause all vaults. When a vault is whitelisted, it can be interacted with through the router. The function will revert if the vault is already in the desired state.","params":{"isWhitelisted":"The whitelist status to set (true to whitelist, false to un-whitelist).","vault_":"The address of the vault to set the whitelist status for. This should be a SLAYVault contract address but isn't \"strictly checked\" (it is not possible to enforce this) to allow for flexible un-whitelisting of vaults for emergency purposes. Importantly: VaultFactory is not used to create vaults using the beacon pattern. Vaults are NOT automatically whitelisted when created to allow for vaults flexibility. This might change in the future."}}},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/","@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/","@openzeppelin/foundry-upgrades/=node_modules/@openzeppelin/foundry-upgrades/src/","@satlayer/contracts/=node_modules/@satlayer/contracts/src/","forge-std/=node_modules/forge-std/src/","solidity-bytes-utils/=node_modules/solidity-bytes-utils/"],"optimizer":{"enabled":false,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"node_modules/@satlayer/contracts/src/interface/ISLAYRouterV2.sol":"ISLAYRouterV2"},"evmVersion":"cancun","libraries":{}},"sources":{"node_modules/@satlayer/contracts/src/interface/ISLAYRouterV2.sol":{"keccak256":"0x5977420f6dbe0cbe211094e6b11bc70d069ff152f6504efe4a8bd342ac30e93b","urls":["bzz-raw://b0c6c50282e932a0a9ca6d5f9b44d6dd6b9430f9bbb0ce9bab420333bced0f12","dweb:/ipfs/Qmazc4YJJoV9TpvonP7RnZ3EC34c7YXRMECEjg3GHurA4N"],"license":"BUSL-1.1"}},"version":1},"id":78}